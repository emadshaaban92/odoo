# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import _, api, fields, models

class ProjectTaskRecurrence(models.Model):
    _name = 'project.task.recurrence'
    _recurrent_model = 'project.task'
    _inherit = 'recurrence.mixin'
    _description = 'Task Recurrence'

    next_recurrence_date = fields.Date()
    recurrence_left = fields.Integer(string="Number of Tasks Left to Create", copy=False)
    recurrent_template_id = fields.Many2one(_recurrent_model)
    recurrent_ids = fields.One2many(_recurrent_model, 'recurrence_id')

    @api.model
    def _get_recurrent_fields_to_copy(self):
        return super()._get_recurrent_fields_to_postpone() + [
            'message_partner_ids',
            'company_id',
            'description',
            'displayed_image_id',
            'email_cc',
            'parent_id',
            'partner_email',
            'partner_id',
            'partner_phone',
            'planned_hours',
            'project_id',
            'display_project_id',
            'project_privacy_visibility',
            'sequence',
            'tag_ids',
            'name',
            'analytic_account_id',
            'user_ids'
        ]

    @api.model
    def _get_recurrent_fields_to_postpone(self):
        return super()._get_recurrent_fields_to_postpone() + ['date_deadline']

    def _create_subtasks(self, task, new_task, depth=3):
        if depth == 0 or not task.child_ids:
            return
        children = []
        child_recurrence = []
        # copy the subtasks of the original task
        for child in task.child_ids:
            if child.recurrence_id and child.recurrence_id.id in child_recurrence:
                # The subtask has been generated by another subtask in the childs
                # This subtasks is skipped as it will be meant to be a copy of the first
                # task of the recurrence we just created.
                continue
            child_values = self._new_task_values(child)
            child_values['parent_id'] = new_task.id
            if child.recurrence_id:
                # The subtask has a recurrence, the recurrence is thus copied rather than used
                # with raw reference in order to decouple the recurrence of the initial subtask
                # from the recurrence of the copied subtask which will live its own life and generate
                # subsequent tasks.
                child_recurrence += [child.recurrence_id.id]
                child_values['recurrence_id'] = child.recurrence_id.copy().id
            if child.child_ids and depth > 1:
                # If child has childs in the following layer and we will have to copy layer, we have to
                # first create the new_child record in order to have a new parent_id reference for the
                # "grandchildren" tasks
                new_child = self.env['project.task'].sudo().create(child_values)
                self._create_subtasks(child, new_child, depth=depth - 1)
            else:
                children.append(child_values)
        self.env['project.task'].sudo().create(children)

    def _create_occurence(self):
        self.ensure_one()
        task = self.sudo().task_ids[-1]
        create_values = self._create_occurence_values(self.next_recurrence_date)
        new_task = self.env['project.task'].sudo().create(create_values)
        self._create_subtasks(task, new_task, depth=3)

    def _set_next_recurrence_date(self):
        today = fields.Date.today()
        for recurrence in self.filtered(
            lambda r:
            r.repeat_type == 'number' and r.recurrence_left >= 0
            or r.repeat_type == 'until' and r.repeat_until >= today
            or r.repeat_type == 'forever'
        ):
            if recurrence.repeat_type == 'number' and recurrence.recurrence_left == 0:
                recurrence.next_recurrence_date = False
            else:
                next_date = self._get_next_occurences_dates(
                    recurrence.next_recurrence_date,
                    recurrence.repeat_interval,
                    recurrence.repeat_unit,
                    recurrence.repeat_type,
                    recurrence.repeat_until
                )
                recurrence.next_recurrence_date = next_date[0] if next_date else False

    @api.model
    def _cron_create_recurring_tasks(self):
        if not self.env.user.has_group('project.group_project_recurring_tasks'):
            return
        today = fields.Date.today()
        recurring_today = self.search([('next_recurrence_date', '<=', today)])
        for recurrence in recurring_today:
            recurrence._create_occurence()
            if recurrence.repeat_type == 'number':
                recurrence.recurrence_left -= 1
        recurring_today._set_next_recurrence_date()

    @api.model_create_multi
    def create(self, vals_list):
        for vals in vals_list:
            if vals.get('repeat_number'):
                vals['recurrence_left'] = vals.get('repeat_number')
        recurrences = super().create(vals_list)
        recurrences._set_next_recurrence_date()
        return recurrences

    def write(self, vals):
        if vals.get('repeat_number'):
            vals['recurrence_left'] = vals.get('repeat_number')

        res = super(ProjectTaskRecurrence, self).write(vals)

        if 'next_recurrence_date' not in vals:
            self._set_next_recurrence_date()
        return res
