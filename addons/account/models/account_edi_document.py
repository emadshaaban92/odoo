# -*- coding: utf-8 -*-
# Part of Odoo. See LICENSE file for full copyright and licensing details.

from odoo import models, fields, api, _
from odoo.exceptions import UserError

from psycopg2 import OperationalError
import base64
import logging

_logger = logging.getLogger(__name__)

DEFAULT_BLOCKING_LEVEL = 'error'


class AccountEdiDocument(models.Model):
    _name = 'account.edi.document'
    _description = 'Electronic Document for an account.move'

    # == Stored fields ==
    move_id = fields.Many2one('account.move', required=True, ondelete='cascade')
    edi_format_id = fields.Many2one('account.edi.format', required=True)
    attachment_id = fields.Many2one('ir.attachment', help='The file generated by edi_format_id when the invoice is posted (and this document is processed).')
    is_validated = fields.Boolean(help="Whether the document has been signed/accepted by the government, meaning the linked attachment can no longer be touched", default=False)

    # message_level
    blocking_level = fields.Selection(selection=[('info', 'Info'), ('warning', 'Warning'), ('error', 'Error')])
    message = fields.Html(help='The text of the last error/warning/note that happened during Electronic Invoice operation.')

    # == Not stored fields == TODO: remove if possible
    name = fields.Char(related='attachment_id.name')
    edi_format_name = fields.Char(string='Format Name', related='edi_format_id.name')
    edi_content = fields.Binary(compute='_compute_edi_content', compute_sudo=True)

    #_sql_constraints = [
    #    (
    #        'unique_edi_document_by_move_by_format',
    #        'UNIQUE(edi_format_id, move_id)',
    #        'Only one edi document by move by format',
    #    ),
    #]

    # Maps formats and field states

    def _get_document_field_state(self):
        self.ensure_one()
        code = self.edi_format_id.code
        field_name = self.env['account.move']._get_mapping_format_field().get(code)
        if field_name:
            print("Document field state: ", getattr(self.move_id, field_name))
            return getattr(self.move_id, field_name)

    @api.depends('move_id', 'message', 'is_validated')
    def _compute_edi_content(self):
        for doc in self:
            res = b''
            if not doc.is_validated:
                move = doc.move_id
                config_errors = doc.edi_format_id._check_move_configuration(move)
                if config_errors:
                    res = base64.b64encode('\n'.join(config_errors).encode('UTF-8'))
                elif move.is_invoice(include_receipts=True) and doc.edi_format_id._is_required_for_invoice(move):
                    res = base64.b64encode(doc.edi_format_id._get_invoice_edi_content(doc.move_id))
                elif move.payment_id and doc.edi_format_id._is_required_for_payment(move):
                    res = base64.b64encode(doc.edi_format_id._get_payment_edi_content(doc.move_id))
            doc.edi_content = res

    def action_export_xml(self):
        self.ensure_one()
        return {
            'type': 'ir.actions.act_url',
            'url':  '/web/content/account.edi.document/%s/edi_content' % self.id
        }

    def _prepare_jobs(self):
        """Creates a list of jobs to be performed by '_process_job' for the documents in self.
        Each document represent a job, BUT if multiple documents have the same state, edi_format_id,
        doc_type (invoice or payment) and company_id AND the edi_format_id supports batching, they are grouped
        into a single job.

        :returns:         A list of tuples (documents, doc_type)
        * documents:      The documents related to this job. If edi_format_id does not support batch, length is one
        * doc_type:       Are the moves of this job invoice or payments ?
        """

        # Classify jobs by (edi_format, edi_doc.state, doc_type, move.company_id, custom_key)
        to_process = {}
        documents = self.filtered(lambda d: d._get_document_field_state() in ('to_send', 'to_cancel') and d.blocking_level != 'error')
        for edi_doc in documents:
            move = edi_doc.move_id
            edi_format = edi_doc.edi_format_id
            if move.is_invoice(include_receipts=True):
                doc_type = 'invoice'
            elif move.payment_id or move.statement_line_id:
                doc_type = 'payment'
            else:
                continue

            custom_key = edi_format._get_batch_key(edi_doc.move_id, edi_doc._get_document_field_state())
            key = (edi_format, edi_doc._get_document_field_state(), doc_type, move.company_id, custom_key)
            to_process.setdefault(key, self.env['account.edi.document'])
            to_process[key] |= edi_doc

        # Order payments/invoice and create batches.
        invoices = []
        payments = []
        for key, documents in to_process.items():
            edi_format, state, doc_type, company_id, custom_key = key
            target = invoices if doc_type == 'invoice' else payments
            batch = self.env['account.edi.document']
            for doc in documents:
                if edi_format._support_batching(move=doc.move_id, state=state, company=company_id):
                    batch |= doc
                else:
                    target.append((doc, doc_type))
            if batch:
                target.append((batch, doc_type))
        return invoices + payments

    @api.model
    def _process_documents(self, documents, doc_type):
        # TODO: put on the move, not on the documents
        domains_to_process = []
        actions = documents.move_id._edi_get_actions_to_process()
        for domain, processor in actions:
            domains_to_process.append(domain)
            move = self.move_id.filtered_domain(domain)
            if move:
                getattr(move, processor)(doc_type)
        return domains_to_process

    def _process_documents_no_web_services(self):
        """ Post and cancel all the documents that don't need a web service.
        """
        jobs = self.filtered(lambda d: not d.edi_format_id._needs_web_services())._prepare_jobs()
        for documents, doc_type in jobs:
            self._process_documents(documents, doc_type)

    def _process_documents_web_services(self, job_count=None, with_commit=True):
        ''' Post and cancel all the documents that need a web service.

        :param job_count:   The maximum number of jobs to process if specified.
        :param with_commit: Flag indicating a commit should be made between each job.
        :return:            The number of remaining jobs to process.
        '''
        all_jobs = self._prepare_jobs()
        jobs_to_process = all_jobs[0:job_count] if job_count else all_jobs

        for documents, doc_type in jobs_to_process:
            move_to_lock = documents.move_id
            attachments_potential_unlink = documents.attachment_id.filtered(lambda a: not a.res_model and not a.res_id)
            try:
                with self.env.cr.savepoint(flush=False):
                    self._cr.execute('SELECT * FROM account_edi_document WHERE id IN %s FOR UPDATE NOWAIT', [tuple(documents.ids)])
                    self._cr.execute('SELECT * FROM account_move WHERE id IN %s FOR UPDATE NOWAIT', [tuple(move_to_lock.ids)])

                    # Locks the attachments that might be unlinked
                    if attachments_potential_unlink:
                        self._cr.execute('SELECT * FROM ir_attachment WHERE id IN %s FOR UPDATE NOWAIT', [tuple(attachments_potential_unlink.ids)])

            except OperationalError as e:
                if e.pgcode == '55P03':
                    _logger.debug('Another transaction already locked documents rows. Cannot process documents.')
                    if not with_commit:
                        raise UserError(_('This document is being sent by another process already. '))
                    continue
                else:
                    raise e
            self._process_documents(documents, doc_type)
            if with_commit and len(jobs_to_process) > 1:
                self.env.cr.commit()

        return len(all_jobs) - len(jobs_to_process)

    @api.model
    def _cron_process_documents_web_services(self, job_count=None):
        ''' Method called by the EDI cron processing all web-services.

        :param job_count: Limit explicitely the number of web service calls. If not provided, process all.
        '''
        edi_documents = self.search([('is_validated', '=', 'False')])
        edi_documents = edi_documents.filtered(lambda d: d.edi_format_id._needs_web_services())
        nb_remaining_jobs = edi_documents._process_documents_web_services(job_count=job_count)

        # Mark the CRON to be triggered again asap since there is some remaining jobs to process.
        if nb_remaining_jobs > 0:
            self.env.ref('account_edi.ir_cron_edi_network')._trigger()


    # TO OVERRIDE
    def _postprocess_post_edi_results(self, edi_result):
        attachments_to_unlink = self.env['ir.attachment']
        for document in self:
            move = document.move_id
            move_result = edi_result.get(move, {})
            if move_result.get('attachment'):
                old_attachment = document.attachment_id
                document.attachment_id = move_result['attachment']
                if not old_attachment.res_model or not old_attachment.res_id:
                    attachments_to_unlink |= old_attachment
            if move_result.get('success') is True:
                state_field = move._get_mapping_format_field().get(document.edi_format_id.code)
                if state_field:
                    setattr(move, state_field, 'sent')
                document.write({
                    #'state': 'sent',
                    'message': False,
                    'blocking_level': False,
                })
            else:
                document.write({
                    'message': move_result.get('error', False),
                    'blocking_level': move_result.get('blocking_level',
                                                      DEFAULT_BLOCKING_LEVEL) if 'error' in move_result else False,
                })

        # Attachments that are not explicitly linked to a business model could be removed because they are not
        # supposed to have any traceability from the user.
        attachments_to_unlink.unlink()

    def _postprocess_cancel_edi_results(self, edi_result):
        invoice_ids_to_cancel = set()  # Avoid duplicates
        attachments_to_unlink = self.env['ir.attachment']
        for document in self:
            move = document.move_id
            move_result = edi_result.get(move, {})
            if move_result.get('success') is True:
                old_attachment = document.attachment_id
                state_field = move._get_mapping_format_field().get(document.edi_format_id.code)
                if state_field:
                    setattr(move, state_field, 'cancelled')
                document.write({
                    #'state': 'cancelled',
                    'message': False,
                    'attachment_id': False,
                    'blocking_level': False,
                })

                if move.is_invoice(include_receipts=True) and move.state == 'posted':
                    # The user requested a cancellation of the EDI and it has been approved. Then, the invoice
                    # can be safely cancelled.
                    invoice_ids_to_cancel.add(move.id)

                if not old_attachment.res_model or not old_attachment.res_id:
                    attachments_to_unlink |= old_attachment

            else:
                document.write({
                    'message': move_result.get('error', False),
                    'blocking_level': move_result.get('blocking_level', DEFAULT_BLOCKING_LEVEL) if move_result.get(
                        'error') else False,
                })

        if invoice_ids_to_cancel:
            invoices = self.env['account.move'].browse(list(invoice_ids_to_cancel))
            invoices.button_draft()
            invoices.button_cancel()

        # Attachments that are not explicitly linked to a business model could be removed because they are not
        # supposed to have any traceability from the user.
        attachments_to_unlink.unlink()
